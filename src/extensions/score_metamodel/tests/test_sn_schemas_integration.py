# *******************************************************************************
# Copyright (c) 2026 Contributors to the Eclipse Foundation
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Apache License Version 2.0 which is available at
# https://www.apache.org/licenses/LICENSE-2.0
#
# SPDX-License-Identifier: Apache-2.0
# *******************************************************************************
# pyright: reportPrivateUsage=false
"""Integration tests for schema generation against the real SCORE metamodel.

Test Design
-----------

Objective:
    Verify that the schemas generated by ``sn_schemas.py`` from the real
    ``metamodel.yaml`` correctly accept valid needs and reject invalid ones.
    This proves the schema-based validation (sphinx-needs 6) is a faithful
    translation of the metamodel rules previously enforced only by Python
    checks in ``checks/check_options.py``.

Approach:
    1. Load the S-Core ``metamodel.yaml`` via ``load_metamodel_data()``.
    2. Generate schemas for every need type via ``_build_need_type_schema()``.
    3. Validate sample needs against the generated schemas using
       ``jsonschema_rs.Draft7Validator``, the same JSON Schema engine
       sphinx-needs uses at build time.

Test categories:

    **Structural sweep** (``TestAllSchemasStructural``)
        Iterates over ALL need types from the S-Core metamodel and verifies:
        - Every generated schema is a valid JSON Schema (constructable).
        - Schema structure matches the sphinx-needs contract
          (id, severity, select, validate.local).
        - The ``select`` schema matches only the correct need type.
        - Fields in ``IGNORE_FIELDS`` (e.g. ``content``) are excluded.
        - Every ``mandatory_options`` field appears in ``required``.
        - Every ``optional_options`` field appears in ``properties``
          but NOT in ``required``.
        - Regex patterns in schemas match the metamodel definitions exactly.
        - Types without any constraints produce no schema.

    **Representative type tests** (``TestFeatReqSchema``, ``TestCompSchema``,
    ``TestFeatSchema``)
        For a curated set of need types, construct valid and invalid need
        dicts and assert the schema accepts or rejects them. This covers
        the constraint categories that exist in the metamodel:

        - ``feat_req``: Mandatory fields with regex patterns
          (reqtype, security, safety, status), optional fields with patterns
          (reqcovered, testcovered), mandatory link with plain target
          (satisfies -> stkh_req, no local link validation), and ``content``
          in ``IGNORE_FIELDS``.
        - ``comp``: Mandatory fields only, no mandatory links.
        - ``feat``: Mandatory link with regex pattern
          (includes: ``^logic_arc_int(_op)*__.+$``), producing a local
          ``minItems: 1`` constraint.

Validation helpers:
    ``assert_schema_valid`` / ``assert_schema_invalid`` replicate the
    two-step sphinx-needs validation: first match the ``select`` schema
    (ensures the schema applies to the need's type), then validate against
    ``validate.local``.

Limitations:
    - Graph checks (safety level decomposition, prohibited words) remain in
      Python code and are outside the scope of schema-based validation.
    - The ``content`` field is excluded via ``IGNORE_FIELDS`` because it is
      not yet available in ubCode; this exclusion is explicitly tested.
"""

from typing import Any

import jsonschema_rs
import pytest

from src.extensions.score_metamodel.metamodel_types import ScoreNeedType
from src.extensions.score_metamodel.sn_schemas import (
    IGNORE_FIELDS,
    _build_need_type_schema,
)
from src.extensions.score_metamodel.yaml_parser import (
    MetaModelData,
    load_metamodel_data,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture(scope="module")
def metamodel() -> MetaModelData:
    """Load the S-Core metamodel.yaml once for all tests in this module."""
    return load_metamodel_data()


@pytest.fixture(scope="module")
def schemas_by_type(metamodel: MetaModelData) -> dict[str, dict[str, Any]]:
    """Generate sphinx-needs schemas for all need types and index by directive name."""
    result: dict[str, dict[str, Any]] = {}
    for need_type in metamodel.needs_types:
        schema = _build_need_type_schema(need_type)
        if schema is not None:
            result[need_type["directive"]] = schema
    return result


@pytest.fixture(scope="module")
def need_types_by_directive(metamodel: MetaModelData) -> dict[str, ScoreNeedType]:
    """Index need types by directive name for easy lookup."""
    return {nt["directive"]: nt for nt in metamodel.needs_types}


# =============================================================================
# Helpers
# =============================================================================


def assert_schema_valid(need_dict: dict[str, Any], schema: dict[str, Any]) -> None:
    """Assert that a need dict passes the schema's local validator."""
    select_validator = jsonschema_rs.Draft7Validator(schema["select"])
    assert select_validator.is_valid(need_dict), (
        f"Need type '{need_dict.get('type')}' did not match schema selector"
    )
    local_validator = jsonschema_rs.Draft7Validator(schema["validate"]["local"])
    # raises ValidationError with details on failure
    local_validator.validate(need_dict)


def assert_schema_invalid(need_dict: dict[str, Any], schema: dict[str, Any]) -> None:
    """Assert that a need dict FAILS the schema's local validator."""
    select_validator = jsonschema_rs.Draft7Validator(schema["select"])
    assert select_validator.is_valid(need_dict), (
        f"Need type '{need_dict.get('type')}' did not match schema selector"
    )
    local_validator = jsonschema_rs.Draft7Validator(schema["validate"]["local"])
    assert not local_validator.is_valid(need_dict), (
        f"Expected validation to fail for need: {need_dict}"
    )


# =============================================================================
# Structural sweep over all types
# =============================================================================


class TestAllSchemasStructural:
    """Verify every schema generated from the real metamodel is well-formed."""

    def test_at_least_one_schema_generated(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        assert len(schemas_by_type) > 0

    def test_all_schemas_are_valid_json_schemas(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """Every schema's select and validate.local must be constructable."""
        for schema in schemas_by_type.values():
            jsonschema_rs.Draft7Validator(schema["select"])
            jsonschema_rs.Draft7Validator(schema["validate"]["local"])

    def test_every_schema_has_required_structure(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            assert schema["id"] == f"need-type-{type_name}"
            assert "severity" in schema
            assert "select" in schema
            assert "local" in schema["validate"]

    def test_select_matches_correct_type_only(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            selector = jsonschema_rs.Draft7Validator(schema["select"])
            assert selector.is_valid({"type": type_name})
            assert not selector.is_valid({"type": f"NOT_{type_name}"})

    def test_ignored_fields_never_in_schemas(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            local = schema["validate"]["local"]
            for field in IGNORE_FIELDS:
                assert field not in local.get("properties", {}), (
                    f"{type_name}: '{field}' should be ignored"
                )
                assert field not in local.get("required", []), (
                    f"{type_name}: '{field}' should be ignored"
                )

    def test_mandatory_options_are_required(
        self,
        schemas_by_type: dict[str, dict[str, Any]],
        need_types_by_directive: dict[str, ScoreNeedType],
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            need_type = need_types_by_directive[type_name]
            local = schema["validate"]["local"]
            for field in need_type.get("mandatory_options", {}):
                if field in IGNORE_FIELDS:
                    continue
                assert field in local["required"], (
                    f"{type_name}: mandatory field '{field}' missing from required"
                )

    def test_optional_options_not_required(
        self,
        schemas_by_type: dict[str, dict[str, Any]],
        need_types_by_directive: dict[str, ScoreNeedType],
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            need_type = need_types_by_directive[type_name]
            local = schema["validate"]["local"]
            for field in need_type.get("optional_options", {}):
                if field in IGNORE_FIELDS:
                    continue
                assert field in local["properties"], (
                    f"{type_name}: optional field '{field}' missing from properties"
                )
                assert field not in local["required"], (
                    f"{type_name}: optional field '{field}' should not be required"
                )

    def test_mandatory_option_patterns_match_metamodel(
        self,
        schemas_by_type: dict[str, dict[str, Any]],
        need_types_by_directive: dict[str, ScoreNeedType],
    ) -> None:
        for type_name, schema in schemas_by_type.items():
            need_type = need_types_by_directive[type_name]
            local = schema["validate"]["local"]
            for field, pattern in need_type.get("mandatory_options", {}).items():
                if field in IGNORE_FIELDS:
                    continue
                prop = local["properties"][field]
                if prop.get("type") == "array":
                    assert prop["items"]["pattern"] == pattern, (
                        f"{type_name}.{field}: pattern mismatch"
                    )
                else:
                    assert prop["pattern"] == pattern, (
                        f"{type_name}.{field}: pattern mismatch"
                    )

    def test_types_without_constraints_have_no_schema(
        self,
        metamodel: MetaModelData,
        schemas_by_type: dict[str, dict[str, Any]],
    ) -> None:
        for nt in metamodel.needs_types:
            directive = nt["directive"]
            has_constraints = bool(
                nt.get("mandatory_options")
                or nt.get("optional_options")
                or nt.get("mandatory_links")
                or nt.get("optional_links")
            )
            if not has_constraints:
                assert directive not in schemas_by_type, (
                    f"{directive} has no constraints but got a schema"
                )


# =============================================================================
# feat_req: mandatory fields, mandatory link (plain target = no local link check)
# =============================================================================


class TestFeatReqSchema:
    """Integration tests for feat_req using the real metamodel."""

    @staticmethod
    def _make_valid() -> dict[str, Any]:
        return {
            "type": "feat_req",
            "id": "feat_req__test__001",
            "reqtype": "Functional",
            "security": "YES",
            "safety": "QM",
            "status": "valid",
            "satisfies": ["stkh_req__some_need"],
        }

    def test_valid_need_passes(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        assert_schema_valid(self._make_valid(), schemas_by_type["feat_req"])

    def test_missing_status_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        del need["status"]
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_missing_safety_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        del need["safety"]
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_wrong_status_pattern_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["status"] = "approved"  # not in ^(valid|invalid)$
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_wrong_safety_pattern_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["safety"] = "ASIL_D"  # not in ^(QM|ASIL_B)$
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_wrong_reqtype_pattern_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["reqtype"] = "Performance"  # not in ^(Functional|Interface|...)$
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_content_not_validated(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """content is in IGNORE_FIELDS — missing content must not fail."""
        need = self._make_valid()
        # no 'content' key at all — should still pass
        assert_schema_valid(need, schemas_by_type["feat_req"])

    def test_invalid_optional_field_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["reqcovered"] = "MAYBE"  # not in ^(YES|NO)$
        assert_schema_invalid(need, schemas_by_type["feat_req"])

    def test_valid_optional_field_passes(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["reqcovered"] = "YES"
        assert_schema_valid(need, schemas_by_type["feat_req"])

    def test_extra_unknown_fields_pass(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["unknown_field"] = "anything"
        assert_schema_valid(need, schemas_by_type["feat_req"])


# =============================================================================
# comp: mandatory fields, no mandatory links
# =============================================================================


class TestCompSchema:
    """Integration tests for comp using the real metamodel."""

    @staticmethod
    def _make_valid() -> dict[str, Any]:
        return {
            "type": "comp",
            "id": "comp__my_component",
            "security": "YES",
            "safety": "QM",
            "status": "valid",
        }

    def test_valid_need_passes(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        assert_schema_valid(self._make_valid(), schemas_by_type["comp"])

    def test_missing_security_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        del need["security"]
        assert_schema_invalid(need, schemas_by_type["comp"])

    def test_wrong_security_pattern_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["security"] = "MAYBE"  # not in ^(YES|NO)$
        assert_schema_invalid(need, schemas_by_type["comp"])


# =============================================================================
# feat: mandatory link with regex (includes: ^logic_arc_int(_op)*__.+$)
# =============================================================================


class TestFeatSchema:
    """Integration tests for feat — has a mandatory link with regex pattern."""

    @staticmethod
    def _make_valid() -> dict[str, Any]:
        return {
            "type": "feat",
            "id": "feat__my_feature",
            "security": "YES",
            "safety": "QM",
            "status": "valid",
            "includes": ["logic_arc_int__something"],
            "consists_of": ["comp__some_component"],
        }

    def test_valid_need_passes(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        assert_schema_valid(self._make_valid(), schemas_by_type["feat"])

    def test_missing_mandatory_link_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        del need["includes"]
        assert_schema_invalid(need, schemas_by_type["feat"])

    def test_empty_mandatory_link_fails(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        need = self._make_valid()
        need["includes"] = []  # minItems: 1 violated
        assert_schema_invalid(need, schemas_by_type["feat"])


# =============================================================================
# Network validation: plain type targets produce validate.network entries
# =============================================================================


class TestNetworkValidation:
    """Verify validate.network schemas for types with plain-target links."""

    def test_mandatory_link_has_network_entry(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """feat_req: satisfies -> stkh_req produces a network entry."""
        schema = schemas_by_type["feat_req"]
        network = schema["validate"].get("network")
        assert network is not None
        assert "satisfies" in network
        entry = network["satisfies"]
        assert entry["type"] == "array"
        assert entry["items"]["local"]["properties"]["type"]["const"] == "stkh_req"
        assert entry["items"]["local"]["required"] == ["type"]

    def test_mandatory_link_has_local_min_items(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """feat_req: mandatory satisfies link gets minItems: 1 in local validator."""
        schema = schemas_by_type["feat_req"]
        local = schema["validate"]["local"]
        assert "satisfies" in local["required"]
        assert local["properties"]["satisfies"] == {"type": "array", "minItems": 1}

    def test_optional_link_excluded_from_network(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """tool_req: satisfies is optional, so no network entry is generated.

        Optional link type violations are treated as informational by the Python
        validate_links() check (treat_as_info=True).  Since schemas use a single
        severity per need type, optional links are excluded from network to avoid
        escalating info-level issues to errors.
        """
        schema = schemas_by_type["tool_req"]
        network = schema["validate"].get("network", {})
        assert "satisfies" not in network

    def test_network_validates_linked_need_type(
        self, schemas_by_type: dict[str, dict[str, Any]]
    ) -> None:
        """The local schema inside items validates a linked need's type field."""
        schema = schemas_by_type["feat_req"]
        network = schema["validate"]["network"]
        local_schema = network["satisfies"]["items"]["local"]
        validator = jsonschema_rs.Draft7Validator(local_schema)
        # Valid linked need
        assert validator.is_valid({"type": "stkh_req"})
        # Invalid linked need type
        assert not validator.is_valid({"type": "comp_req"})

    def test_all_mandatory_plain_links_have_local_and_network(
        self,
        schemas_by_type: dict[str, dict[str, Any]],
        need_types_by_directive: dict[str, ScoreNeedType],
    ) -> None:
        """Structural sweep: every mandatory plain-target link has both entries.

        Fields that mix regex and plain targets are excluded from network
        validation (the items schema would incorrectly require ALL linked
        needs to match the plain type).
        """
        for type_name, schema in schemas_by_type.items():
            need_type = need_types_by_directive[type_name]
            local = schema["validate"]["local"]
            network = schema["validate"].get("network", {})
            for link_field, link_value in need_type.get("mandatory_links", {}).items():
                assert isinstance(link_value, str)  # before postprocess_need_links
                values = [v.strip() for v in link_value.split(",")]
                plain_targets = [v for v in values if not v.startswith("^")]
                has_regex = any(v.startswith("^") for v in values)
                if not plain_targets:
                    continue
                # Must have local minItems: 1
                assert link_field in local["required"], (
                    f"{type_name}.{link_field}: missing from local required"
                )
                assert local["properties"][link_field] == {
                    "type": "array",
                    "minItems": 1,
                }, f"{type_name}.{link_field}: wrong local properties"
                # Network type constraint only for non-mixed fields
                if has_regex:
                    assert link_field not in network, (
                        f"{type_name}.{link_field}: mixed field should NOT be in "
                        "network"
                    )
                else:
                    assert link_field in network, (
                        f"{type_name}.{link_field}: missing from network"
                    )
